= Simple ToDo-List
// --- D O N ' T    T O U C H   T H I S    S E C T I O N ---
:toc:
:toc-placement!:
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
// ----------------------------------------------------------



// Write a short summary here what this examples does
This example will show you how a simple ToDo-List App can be build using Avalonia in combination with the MVVM-Community-Toolkit.



// --- D O N ' T    T O U C H   T H I S    S E C T I O N ---
toc::[]
// ---------------------------------------------------------


=== Difficulty
// Choose one of the below difficulties. You can just delete the ones you don't need.

🐥 Easy 🐥


=== Buzz-Words

// Write some buzz-words here. You can separate them by ", "
ToDo-List, complete app, MVVM, CommunityToolkit.MVVM, source generator, styles, commands



== Before we start

This sample assumes that you have a basic knowledge about the following topcis:

- How to create a https://docs.avaloniaui.net/docs/get-started/test-drive/create-a-project[[new Avalonia project\]]
- Some basics about C# and https://docs.avaloniaui.net/docs/get-started/test-drive/[[XAML\]]
- What the link:../../MVVM/BasicMvvmSample[[MVVM -pattern\]] (Model-View-ViewModel) is and how it works
- What a link:../../MVVM/CommandSample[[Command\]] is and how it works
- What a link:https://learn.microsoft.com/en-us/dotnet/api/system.collections.objectmodel.observablecollection-1?view=net-8.0[ObservableCollection] is and how it works

TIP: Some sections are optional. You can skip these if you want to.

=== CommunityToolkit.MVVM

The https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/[[CommunityToolkit.MVVM\]]-package is one of many third-party packages for MVVM-Apps. We will use it in this sample as it is very lightweight. In addition, it comes with built-in source generators which allows us to write less boilerplate code.

[TIP]
====
For example we can annotate private fields with the `[ObservableProperty]`-attribute which will let the source generator create a property for us:

[source,cs]
----
// Using the source generator:
[ObservableProperty]
private bool _IsChecked;

// Without using the source generator we would need to write:
private bool _IsChecked;

public bool IsChecked
{
    get { return _IsChecked; }
    set { SetProperty(ref _IsChecked, value); }
}
----
====
NOTE: If you want to learn more about how these source generators work, please see https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/generators/overview[[here\]] and https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview[[here\]].

=== Preparation work

Before we start with the actual implementation of the App, we need to define a list of requirements and a sketch of the UI.

**Must-Haves**

- The user must be able to view a list of to-do items
- All items must be easily discoverable
- The user must be able to check and uncheck the to-do items
- The user must be able to add new items
- The user must be able to delete an existing item

**Nice-To-Haves**

- The user should have a visual feedback when hovering a to-do item
- The user should have a visual feedback if a new item can be added or not
- The user should be able to save and load a to-do-list (not a scope of this tutorial)
- The user should be able to edit an existing item (not a scope of this tutorial)

**Draft UI Layout**

It would be nice to have a single page user interface (UI) where the user can interact with the to-do list. We will use the operating system's window frame to present our App. In the bottom of the page, the user will have a `TextBox` where they can type any new item content to add. A `Watermark` or `ToolTip` shall indicate that visually. As soon as we receive valid input for a new item, a `Button` next to the input field should be enabled. If the user invokes this `Button`, the new item will be added into our list. The list itself will fill the rest of our available space. In case the space is not enough to render all items, a `ScrollBar` will enable vertical scrolling.
Each item in the list is going to be represented by a `CheckBox` followed by the content and a `Button` to delete the item.

image::_docs/Sketch.png[Sketch of the UI]


== The Solution

NOTE: In this sample we will use the MVVM (Model-View-ViewModel) approach, where we will start with the Model and ViewModel first.

=== Step 1: Create and setup a new project

Choose your favorite IDE to create a new Avalonia-MVVM project.

NOTE: Depending on the IDE used to create your project, you may see a file structure that differs from the one seen in this tutorial.

By default, the Avalonia-MVVM template installs `Avalonia.ReactiveUI` as the MVVM framework. However, we want to use another MVVM framework. Therefor we will uninstall that package and instead install the `CommunityToolkit.Mvvm` package. We need to edit two files to get the changes applied:

**Program.cs**:
[source,diff]
----
    using Avalonia;
-   using Avalonia.ReactiveUI; // remove this using
    using System;

[...]

    public static AppBuilder BuildAvaloniaApp()
        => AppBuilder.Configure<App>()
            .UsePlatformDetect()
            .WithInterFont()
            .LogToTrace();
-           .UseReactiveUI(); // remove this line
----

**ViewModels/ViewModelBase**
[source,diff]
----
-   using ReactiveUI;
+   using CommunityToolkit.Mvvm.ComponentModel;

    namespace GetStartedApp.ViewModels;

-   public class ViewModelBase : ReactiveObject
+   public class ViewModelBase : ObservableObject
    {
    }
----


=== Step 2: Setup the Model

TIP: In our case we need the model for I/O operations. If you have no use for the model in your own App, feel free to skip that part.

The Model will be quite simple in our case. We want to have one class called `ToDoItem`, which has two `Properties`. This model will also be used to save and restore the users ToDo-List later on. Inside the folder `Models`, add a new class called `ToDoItem`:

[source,cs]
.Models/ToDoItem.cs
----
/// <summary>
/// This is our Model for a simple ToDoItem.
/// </summary>
public class ToDoItem
{
    /// <summary>
    /// Gets or sets the checked status of each item
    /// </summary>
    public bool IsChecked { get; set; }

    /// <summary>
    /// Gets or sets the content of the to-do item
    /// </summary>
    public string? Content { get; set; }
}
----


=== Step 3: Setup the ViewModel

==== The ToDoItem-ViewModel

Our next task is to create a `ViewModel` for our to-do-items, which we will use as an intermediate layer between the `View` and the `Model`. Inside the folder `ViewModels` add a new class `ToDoItemViewModel` which inherits `ViewModelBase`.

IMPORTANT: If you want to use the source generators, remember to mark the class as `partial`.


[source,cs]
.ViewModels/ToDoItemViewModel.cs
----
/// <summary>
/// This is a ViewModel which represents a <see cref="Models.ToDoItem"/>
/// </summary>
public partial class ToDoItemViewModel : ViewModelBase
{
    /// <summary>
    /// Gets or sets the checked status of each item
    /// </summary>
    [ObservableProperty]
    private bool _IsChecked;

    /// <summary>
    /// Gets or sets the content of the to-do item
    /// </summary>
    /// <returns></returns>
    [ObservableProperty]
    private string? _Content;
}
----

Our `ViewModel` is not yet connected to our `Model`. In order to create a new `ToDoItemViewModel` from an existing `ToDoItem`, we can add a constructor that takes the `ToDoItem` as an argument.

NOTE: We also want to be able to create a new, empty `ToDoItemViewModel`. Therefore, we also add a parameterless constructor.

[source,cs]
----
/// <summary>
/// Creates a new blank ToDoItemViewModel
/// </summary>
public ToDoItemViewModel()
{
    // empty
}

/// <summary>
/// Creates a new ToDoItemViewModel for the given <see cref="Models.ToDoItem"/>
/// </summary>
/// <param name="item">The item to load</param>
public ToDoItemViewModel(ToDoItem item)
{
    // Init the properties with the given values
    IsChecked = item.IsChecked;
    Content = item.Content;
}
----

Okay, now we also need a way to get the updated `Model` back, if the user made some changes. We can do this for example using a read-only property or a method like shown below:

[source,cs]
----
/// <summary>
/// Gets a ToDoItem of this ViewModel
/// </summary>
/// <returns>The ToDoItem</returns>
public ToDoItem GetToDoItem()
{
    return new ToDoItem()
    {
        IsChecked = this.IsChecked,
        Content = this.Content
    };
}
----

==== The MainViewModel

Depending on the template used to create the project you should see a file called `MainViewModel` or `MainWindowViewModel`. Open this file in order to edit it.

TIP: If you see a property called `Greetings`, feel free to delete it as we don't need that in our App.

Let's add an `ObservableCollection` called `ToDoItems`. As the collection will notify the UI whenever an item was added or removed, we can make this property readonly. Thus a getter is enough here. 

[source]
.ViewModels/MainViewModel.cs
----
/// <summary>
/// Gets a collection of <see cref="ToDoItem"/> which allows adding and removing items
/// </summary>
public ObservableCollection<ToDoItemViewModel> ToDoItems { get; } = new ObservableCollection<ToDoItemViewModel>();
----

Well, now we have a collection of `ToDoItems` but how can we add new items to it? In our case this is quite simple as we only expect a non-empty `string` as content to construct a new item. We will add a helper property called `NewItemContent`. If that `string` is not empty, a command called `AddItemCommand` will be enabled.

NOTE: The command and the properties will be created using the source generator provided by the MVVM-toolkit we use. Remember to make the `MainViewModel` `partial`.

[source,cs]
----
/// <summary>
/// Gets or set the content for new Items to add. If this string is not empty, the AddItemCommand will be enabled automatically
/// </summary>
[ObservableProperty]
[NotifyCanExecuteChangedFor(nameof(AddItemCommand))] // This attribute will invalidate the command each time this property changes
private string? _NewItemContent;
----

Next step is to create a method or a property that returns a `bool` indicating whether the `AddItemCommand` can execute:

[source,cs]
----
/// <summary>
/// Returns if a new Item can be added. We require to have the NewItem some Text
/// </summary>
private bool CanAddItem() => !string.IsNullOrWhiteSpace(NewItemContent);
----

Last but not least we can add the `Command`. If we annotate a `void` or a `Task` with the https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/generators/relaycommand[[`RelayCommand`-attribute\]], a new `RelayCommand` will be generated for us. In our case we use a `void` called `AddItem` which will add a new item into `ToDoItems`-collection. After that we want to reset the `NewItemContent`, so that the input field is cleared for the next item to be added.

[source,cs]
----
/// <summary>
/// This command is used to add a new Item to the List
/// </summary>
/// <param name="content"></param>
[RelayCommand (CanExecute = nameof(CanAddItem))]
private void AddItem(string content)
{
    // Add a new item to the list
    ToDoItems.Add(new ToDoItemViewModel() {Content = NewItemContent});

    // reset the NewItemContent
    NewItemContent = null;
}
----

=== Step 4: Setup the View

== Related

// Any related information or further readings goes here.



// --------------- Ascii-Doc Cheat-Sheet ------------------

// visit: https://asciidoc.org 
// visit: https://powerman.name/doc/asciidoc-compact

// VS-Code has a great Add-In for Ascii docs: https://github.com/asciidoctor/asciidoctor-vscode/